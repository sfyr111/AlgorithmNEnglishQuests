# 153. Find Minimum in Rotated Sorted Array

[153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

## Problem

Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:

- `[4,5,6,7,0,1,2]` if it was rotated `4` times.
- `[0,1,2,4,5,6,7]` if it was rotated `7` times.

Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.

You must write an algorithm that runs in `O(log n) time.`

## Solution

1. Check whether the range from left to mid or mid to right is sorted.
2. Confirm if the target is within the sorted range and adjust the edge points accordingly.
3. If the left to middle section is sorted, check if the target is within this section. If yes, move the right edge point toward the mid by one (i.e., `right = mid - 1`). If not, adjust the left edge point (`left = mid + 1`).
4. Repeat the same process if the middle to the right section is sorted.
5. Note that a crucial boundary condition is when the value of the left is equal to the value at the middle.
6. Consider the array length shrinking to 2 elements because the mid is calculated using floor division.
7. If the target is not found, return -1.

```typescript
function search(nums: number[], target: number): number {  
  let left = 0;  
  let right = nums.length - 1;  
  
  // Continue the loop while the left pointer is less than or equal to the right pointer  
  while (left <= right) {  
    // Calculate the middle index by flooring the average of left and right  
    const mid = ((left + right) / 2) | 0;  
  
    // Check if the middle element is the target  
    if (nums[mid] === target) {  
      return mid;  
    }  
    // If the left to middle section is sorted  
    if (nums[left] <= nums[mid]) {  
      // Check if the target is within the left to middle section  
      if (nums[left] <= target && target < nums[mid]) {  
        right = mid - 1; // If yes, move the right pointer just before the middle index  
      } else {  
        left = mid + 1; // If not, move the left pointer beyond the middle index  
      }  
    // If the middle to right section is sorted  
    } else {  
      // Check if the target is within the middle to right section  
      if (nums[mid] < target && target <= nums[right]) {  
        left = mid + 1; // If yes, move the left pointer beyond the middle index  
      } else {  
        right = mid - 1; // If not, move the right pointer just before the middle index  
      }  
    }  
  }  
  
  return -1;  
};
```
