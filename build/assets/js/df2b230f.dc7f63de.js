"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[2626],{3155:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/coin-change-ec54964c96ef9c21fc89be73cbc62868.png"},5680:(e,n,t)=>{t.d(n,{xA:()=>m,yg:()=>d});var a=t(6540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},l="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,m=u(e,["components","mdxType","originalType","parentName"]),l=s(t),p=o,d=l["".concat(c,".").concat(p)]||l[p]||h[p]||r;return t?a.createElement(d,i(i({ref:n},m),{},{components:t})):a.createElement(d,i({ref:n},m))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=p;var u={};for(var c in n)hasOwnProperty.call(n,c)&&(u[c]=n[c]);u.originalType=e,u[l]="string"==typeof e?e:o,i[1]=u;for(var s=2;s<r;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},6972:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>u,toc:()=>s});var a=t(8168),o=(t(6540),t(5680));const r={},i="322. Coin Change",u={unversionedId:"dynamic/Coin Change",id:"dynamic/Coin Change",title:"322. Coin Change",description:"322. Coin Change](https://leetcode.com/problems/coin-change/)",source:"@site/docs/dynamic/322. Coin Change.md",sourceDirName:"dynamic",slug:"/dynamic/Coin Change",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/Coin Change",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/dynamic/322. Coin Change.md",tags:[],version:"current",sidebarPosition:322,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"300. Longest Increasing Subsequence",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/Longest Increasing Subsequence"},next:{title:"509. Fibonacci Number",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/Fibonacci Number"}},c={},s=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],m={toc:s},l="wrapper";function h(e){let{components:n,...r}=e;return(0,o.yg)(l,(0,a.A)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"322-coin-change"},"322. Coin Change"),(0,o.yg)("ol",{start:322},(0,o.yg)("li",{parentName:"ol"},"Coin Change](",(0,o.yg)("a",{parentName:"li",href:"https://leetcode.com/problems/coin-change/"},"https://leetcode.com/problems/coin-change/"),")")),(0,o.yg)("h2",{id:"problem"},"Problem"),(0,o.yg)("p",null,"You are given an integer array\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"coins"),"\xa0representing coins of different denominations and an integer\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"amount"),"\xa0representing a total\xa0amount\xa0of money."),(0,o.yg)("p",null,"Return\xa0",(0,o.yg)("em",{parentName:"p"},"the fewest number of coins that you need to make up that\xa0amount"),". If that\xa0amount\xa0of money cannot be made up by any\xa0combination\xa0of the coins, return\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"-1"),"."),(0,o.yg)("p",null,"You may\xa0assume\xa0that you have an infinite number of each kind of coin."),(0,o.yg)("h2",{id:"solution"},"Solution"),(0,o.yg)("p",null,"I can use dynamic programming to solve this problem because it lets me break down a big problem into smaller tasks. Each small task uses the results from the previous tasks."),(0,o.yg)("p",null,"I create an array where each index represents an amount, and the value at each index shows the minimum coins needed for that amount. I don't start from scratch when I need to calculate the coins for an amount. I just find a suitable coin for the current amount and add the minimum coins needed for the remaining amount (current amount minus the coin value)."),(0,o.yg)("p",null,"So, for each amount, I go through each usable coin. I keep track of the minimum number of coins needed and update the value for that amount in the array until all amounts are processed."),(0,o.yg)("p",null,"In the end, if the final amount has been updated from its initial value, it means I've found the minimum coins needed for that amount. If not, the answer is -1."),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"coin-change",src:t(3155).A,width:"1426",height:"753"})),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-typescript"},'function coinChange(coins: number[], amount: number): number {\n  // Initialize an array to store the minimum coins needed for each amount up to the target amount.\n  // We fill the array with amount + 1, which acts as an "infinity" placeholder value to be minimized later.\n  let dp = new Array(amount + 1).fill(amount + 1);\n\n  // Base case: the minimum coins needed to make an amount of 0 is 0.\n  dp[0] = 0;\n\n  // Start building up the dp array from the smallest amount (1) to the target amount.\n  for (let a = 1; a <= amount; a++) {\n    // Iterate through each coin.\n    for (let c of coins) {\n      // If the current amount minus the coin value is non-negative,\n      // it means we can use this coin for the current amount.\n      if (a - c >= 0) {\n        // Update the dp array for the current amount to be the minimum of itself\n        // or 1 plus the number of coins needed for the amount that remains after using coin c.\n        dp[a] = Math.min(dp[a], 1 + dp[a - c]);\n      }\n    }\n  }\n\n  // After filling the dp array, if the value at the index equal to the target amount\n  // is not our "infinity" value, it means we found a minimum count for the amount.\n  // Otherwise, return -1 to indicate it is not possible to make the amount with any combination of coins.\n  return dp[amount] !== amount + 1 ? dp[amount] : -1;\n}\n')))}h.isMDXComponent=!0}}]);