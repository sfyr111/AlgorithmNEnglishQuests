"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[1116],{5680:(e,t,a)=>{a.d(t,{xA:()=>u,yg:()=>y});var n=a(6540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),m=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=m(e.components);return n.createElement(o.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=m(a),h=r,y=p["".concat(o,".").concat(h)]||p[h]||c[h]||i;return a?n.createElement(y,s(s({ref:t},u),{},{components:a})):n.createElement(y,s({ref:t},u))}));function y(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=h;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[p]="string"==typeof e?e:r,s[1]=l;for(var m=2;m<i;m++)s[m]=a[m];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},6155:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>m});var n=a(8168),r=(a(6540),a(5680));const i={},s="981.\xa0Time Based Key-Value Store",l={unversionedId:"binary search/Time Based Key-Value Store",id:"binary search/Time Based Key-Value Store",title:"981.\xa0Time Based Key-Value Store",description:"981.\xa0Time Based Key-Value Store",source:"@site/docs/binary search/981.\xa0Time Based Key-Value Store.md",sourceDirName:"binary search",slug:"/binary search/Time Based Key-Value Store",permalink:"/docs/binary search/Time Based Key-Value Store",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/binary search/981.\xa0Time Based Key-Value Store.md",tags:[],version:"current",sidebarPosition:981,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"[875.\xa0Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)",permalink:"/docs/binary search/Koko Eating Bananas"},next:{title:"5. Longest Palindromic Substring",permalink:"/docs/dynamic/Longest Palindromic Substring & 647. Palindromic Substrings"}},o={},m=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],u={toc:m},p="wrapper";function c(e){let{components:t,...a}=e;return(0,r.yg)(p,(0,n.A)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"981time-based-key-value-store"},"981.\xa0Time Based Key-Value Store"),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/time-based-key-value-store/"},"981.\xa0Time Based Key-Value Store")),(0,r.yg)("h2",{id:"problem"},"Problem"),(0,r.yg)("p",null,"Design a time-based key-value data\xa0structure\xa0that can store multiple values for the same key at different time stamps and\xa0retrieve\xa0the key's value at a\xa0certain\xa0timestamp."),(0,r.yg)("p",null,"Implement\xa0the\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"TimeMap"),"\xa0class:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"TimeMap()"),"\xa0Initializes the object of the data\xa0structure."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"void set(String key, String value, int timestamp)"),"\xa0Stores the key\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"key"),"\xa0with the value\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"value"),"\xa0at the given time\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"timestamp"),"."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"String get(String key, int timestamp)"),"\xa0Returns a value such that\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"set"),"\xa0was called previously, with\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"timestamp_prev <= timestamp"),". If there are multiple such values, it returns the value\xa0associated\xa0with the largest\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"timestamp_prev"),". If there are no values, it returns\xa0",(0,r.yg)("inlineCode",{parentName:"li"},'""'),".")),(0,r.yg)("h2",{id:"solution"},"Solution"),(0,r.yg)("p",null,"For this problem, our task is to design a data structure that can store and retrieve values based on keys and timestamps. To achieve this, we can associate each key with a list of value-timestamp pairs and store these lists in a hashmap."),(0,r.yg)("p",null,"To set a value, we simply add a new pair to the list that corresponds to the key. Since timestamps are always increasing, this list is inherently sorted by timestamp, which is important for our retrieval method."),(0,r.yg)("p",null,"Retrieval is where it gets interesting. We need to return the value with the highest timestamp that is still less than or equal to the given timestamp. To do this efficiently, we use binary search."),(0,r.yg)("p",null,"Here's how it works: the midpoint in a binary search is rounded down, so it naturally falls into the left partition of the list. If the midpoint's timestamp is less than or equal to the target timestamp, it's a potential match, and we update the result with this value. We then move the left pointer past the midpoint to continue searching for an even closer timestamp. This is because there might be a value with a timestamp closer to, but still less than, the target timestamp. We keep doing this until the left pointer exceeds the right pointer."),(0,r.yg)("p",null,"In summary, this approach combines the use of a hashmap with binary search. Since the lists are sorted by timestamp, it ensures an efficient search for the correct value. This method guarantees that we can set values in constant time and retrieve them in logarithmic time relative to the number of entries for a key."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-typescript"},"class TimeMap {  \n    private map: Map<string, Array<[string, number]>>  \n    constructor() {  \n        this.map = new Map();  \n    }  \n  \n    set(key: string, value: string, timestamp: number): void {  \n        if (!this.map.has(key)) {  \n            this.map.set(key, []);  \n        }        const values = this.map.get(key);  \n        values.push([value, timestamp]);  \n    }  \n  \n    get(key: string, timestamp: number): string {  \n        let res = '';  \n        const values = this.map.get(key) || [];  \n        if (values.length === 0) {  \n            return '';  \n        }  \n        let left = 0;  \n        let right = values.length - 1;  \n  \n        while (left <= right) {  \n            const mid = left + right >> 1;  \n  \n            if (values[mid][1] <= timestamp) {  \n                res = values[mid][0];  \n                left = mid + 1;  \n            } else {  \n                right = mid - 1;  \n            }  \n        }  \n  \n        return res;  \n    }  \n}\n")))}c.isMDXComponent=!0}}]);