"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[7112],{5680:(e,r,t)=>{t.d(r,{xA:()=>d,yg:()=>y});var n=t(6540);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?i(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function l(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=n.createContext({}),c=function(e){var r=n.useContext(s),t=r;return e&&(t="function"==typeof e?e(r):o(o({},r),e)),t},d=function(e){var r=c(e.components);return n.createElement(s.Provider,{value:r},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},h=n.forwardRef((function(e,r){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(t),h=a,y=u["".concat(s,".").concat(h)]||u[h]||p[h]||i;return t?n.createElement(y,o(o({ref:r},d),{},{components:t})):n.createElement(y,o({ref:r},d))}));function y(e,r){var t=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=h;var l={};for(var s in r)hasOwnProperty.call(r,s)&&(l[s]=r[s]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=t[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},6650:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var n=t(8168),a=(t(6540),t(5680));const i={},o="98. Validate Binary Search Tree",l={unversionedId:"trees/Validate Binary Search Tree",id:"trees/Validate Binary Search Tree",title:"98. Validate Binary Search Tree",description:"98. Validate Binary Search Tree",source:"@site/docs/trees/98. Validate Binary Search Tree.md",sourceDirName:"trees",slug:"/trees/Validate Binary Search Tree",permalink:"/AlgorithmNEnglishQuests/docs/trees/Validate Binary Search Tree",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/trees/98. Validate Binary Search Tree.md",tags:[],version:"current",sidebarPosition:98,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"94. Binary Tree Inorder Traversal",permalink:"/AlgorithmNEnglishQuests/docs/trees/Binary Tree Inorder Traversal"},next:{title:"100.\xa0Same Tree",permalink:"/AlgorithmNEnglishQuests/docs/trees/Same Tree"}},s={},c=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],d={toc:c},u="wrapper";function p(e){let{components:r,...t}=e;return(0,a.yg)(u,(0,n.A)({},d,t,{components:r,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"98-validate-binary-search-tree"},"98. Validate Binary Search Tree"),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/validate-binary-search-tree/"},"98. Validate Binary Search Tree")),(0,a.yg)("h2",{id:"problem"},"Problem"),(0,a.yg)("p",null,"Given the\xa0",(0,a.yg)("inlineCode",{parentName:"p"},"root"),"\xa0of a binary tree,\xa0",(0,a.yg)("em",{parentName:"p"},"determine if it is a valid binary search tree (BST)"),"."),(0,a.yg)("p",null,"A\xa0",(0,a.yg)("strong",{parentName:"p"},"valid BST"),"\xa0is\xa0defined\xa0as follows:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"The left\xa0"),(0,a.yg)("p",{parentName:"li"},"  subtree"),(0,a.yg)("p",{parentName:"li"},"of a node contains only nodes with keys\xa0",(0,a.yg)("strong",{parentName:"p"},"less than"),"\xa0the node's key.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"The right subtree of a node contains only nodes with keys\xa0",(0,a.yg)("strong",{parentName:"p"},"greater than"),"\xa0the node's key.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Both the left and right subtrees must also be binary search trees."))),(0,a.yg)("h2",{id:"solution"},"Solution"),(0,a.yg)("p",null,"To check if a binary tree is a valid Binary Search Tree (BST). A BST has all left child nodes less than the parent node, and all right child nodes greater.\nWe use a helper function, dfsValid, to do a Depth-First Search (DFS). It checks if each node's value is within the correct range. The left parameter is the lower \xe5, and right is the upper boundary for the node's value.\nIf a node is null, that's the base case a valid endpoint, so we return true. If a node's value is not within boundaries, we return false, because it breaks the BST rules.\nWe call dfsValid recursively for left and right children, updating bounds. For left children, the current node's value becomes the new upper bound. For right children, it becomes the new lower bound.\nWe start dfsValid with the root node and bounds of negative and positive infinity. This checks the whole tree."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-typescript"},"function isValidBST(root: TreeNode | null): boolean {  \n  \n  function dfsValid(node: TreeNode | null, left: number, right: number) {  \n    if (node === null) {  \n      return true;  \n    }    if (node.val <= left || node.val >= right) {  \n      return false;  \n    }  \n    return dfsValid(node.left, left, node.val)  \n        && dfsValid(node.right, node.val, right);  \n  }  \n  \n  return dfsValid(root, -Infinity, Infinity);  \n};\n")))}p.isMDXComponent=!0}}]);