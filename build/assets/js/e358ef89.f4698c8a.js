"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[1244],{2003:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>f,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var n=r(8168),o=(r(6540),r(5680));const i={},l="101. Symmetric Tree",a={unversionedId:"trees/Symmetric Tree",id:"trees/Symmetric Tree",title:"101. Symmetric Tree",description:"101. Symmetric Tree",source:"@site/docs/trees/101. Symmetric Tree.md",sourceDirName:"trees",slug:"/trees/Symmetric Tree",permalink:"/AlgorithmNEnglishQuests/docs/trees/Symmetric Tree",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/trees/101. Symmetric Tree.md",tags:[],version:"current",sidebarPosition:101,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"100.\xa0Same Tree",permalink:"/AlgorithmNEnglishQuests/docs/trees/Same Tree"},next:{title:"102.\xa0Binary Tree Level Order\xa0Traversal",permalink:"/AlgorithmNEnglishQuests/docs/trees/Binary Tree Level Order\xa0Traversal"}},s={},c=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],u={toc:c},m="wrapper";function f(e){let{components:t,...r}=e;return(0,o.yg)(m,(0,n.A)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"101-symmetric-tree"},"101. Symmetric Tree"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/symmetric-tree/"},"101. Symmetric Tree")),(0,o.yg)("h2",{id:"problem"},"Problem"),(0,o.yg)("p",null,"Given the\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"root"),"\xa0of a binary tree,\xa0",(0,o.yg)("em",{parentName:"p"},"check\xa0whether\xa0it is a\xa0mirror\xa0of itself"),"\xa0(i.e., symmetric around its center)."),(0,o.yg)("h2",{id:"solution"},"Solution"),(0,o.yg)("p",null,"To solve the problem, we can use the Recursive approach. We need to create a function called dfs that takes two nodes, left and right, as inputs. We will compare these two nodes and their respective subtrees. If both left and right are null, we return true. If one of them is null but not both, it returns false. The function checks if the values of left and right are equal. Then it makes two recursive calls: one to compare the right child of left with the left child of right, and another to compare the left child of left with the right child of right. Initially, the function is symmetric and calls dfs with the left and right children of the root node."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-typescript"},"function isSymmetric(root: TreeNode | null): boolean {  \n  \n  function dfs(left: TreeNode, right: TreeNode) {  \n    if (left === null && right === null) {  \n      return true;  \n    }    if (left === null || right === null) {  \n      return false;  \n    }  \n    return left.val === right.val  \n        && dfs(left.right, right.left)  \n        && dfs(left.left, right.right)  \n  }  \n  \n  return dfs(root.left, root.right);  \n};\n")))}f.isMDXComponent=!0},5680:(e,t,r)=>{r.d(t,{xA:()=>u,yg:()=>h});var n=r(6540);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function a(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),m=c(r),p=o,h=m["".concat(s,".").concat(p)]||m[p]||f[p]||i;return r?n.createElement(h,l(l({ref:t},u),{},{components:r})):n.createElement(h,l({ref:t},u))}));function h(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,l=new Array(i);l[0]=p;var a={};for(var s in t)hasOwnProperty.call(t,s)&&(a[s]=t[s]);a.originalType=e,a[m]="string"==typeof e?e:o,l[1]=a;for(var c=2;c<i;c++)l[c]=r[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"}}]);