"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[4715],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>h});var r=t(6540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=r.createContext({}),l=function(e){var n=r.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(u.Provider,{value:n},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},b=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=l(t),b=o,h=m["".concat(u,".").concat(b)]||m[b]||p[b]||a;return t?r.createElement(h,s(s({ref:n},c),{},{components:t})):r.createElement(h,s({ref:n},c))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,s=new Array(a);s[0]=b;var i={};for(var u in n)hasOwnProperty.call(n,u)&&(i[u]=n[u]);i.originalType=e,i[m]="string"==typeof e?e:o,s[1]=i;for(var l=2;l<a;l++)s[l]=t[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}b.displayName="MDXCreateElement"},7172:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=t(8168),o=(t(6540),t(5680));const a={},s="213. House Robber II",i={unversionedId:"dynamic/House Robber II",id:"dynamic/House Robber II",title:"213. House Robber II",description:"213. House Robber II",source:"@site/docs/dynamic/213. House Robber II.md",sourceDirName:"dynamic",slug:"/dynamic/House Robber II",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/House Robber II",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/dynamic/213. House Robber II.md",tags:[],version:"current",sidebarPosition:213,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"198. House Robber",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/House Robber"},next:{title:"300. Longest Increasing Subsequence",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/Longest Increasing Subsequence"}},u={},l=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],c={toc:l},m="wrapper";function p(e){let{components:n,...t}=e;return(0,o.yg)(m,(0,r.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"213-house-robber-ii"},"213. House Robber II"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/house-robber-ii/"},"213. House Robber II")),(0,o.yg)("h2",{id:"problem"},"Problem"),(0,o.yg)("p",null,"You are a\xa0professional\xa0robber planning to rob houses along a street. Each house has a certain\xa0amount\xa0of money stashed. All houses at this place are\xa0",(0,o.yg)("strong",{parentName:"p"},"arranged\xa0in a circle."),"\xa0That means the first house is the neighbor of the last one. Meanwhile,\xa0adjacent\xa0houses have a security system connected, and\xa0",(0,o.yg)("strong",{parentName:"p"},"it will\xa0automatically\xa0contact\xa0the police if two\xa0adjacent\xa0houses were broken into on the same night"),"."),(0,o.yg)("p",null,"Given an integer array\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"nums"),"\xa0representing the\xa0amount\xa0of money of each house, return\xa0",(0,o.yg)("em",{parentName:"p"},"the\xa0maximum\xa0amount\xa0of money you can rob tonight\xa0",(0,o.yg)("strong",{parentName:"em"},"without alerting the police")),"."),(0,o.yg)("h2",{id:"solution"},"Solution"),(0,o.yg)("p",null,"This version of the problem is different from version one. We can't rob the first and last house at the same time. We can solve this by breaking the array into two arrays. The first scenario processes the first to the second last position, excluding the last house. The second scenario processes the second to the last position, excluding the first house. We can use a helper function to find the maximum rob value for each scenario, and then return the greater value. If the nums array has only one element, we return that element."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-typescript"},"function rob(nums: number[]): number {  \n  \n  function helper(houses: number[]) {  \n    let rob1 = 0;  \n    let rob2 = 0;  \n  \n    for (let n of houses) {  \n      const newRob = Math.max(n + rob1, rob2);  \n      rob1 = rob2;  \n      rob2 = newRob;  \n    }  \n    return rob2;  \n  }  \n  \n  if (nums.length === 1)  \n    return nums[0];  \n  \n  return Math.max(helper(nums.slice(1)), helper(nums.slice(0, -1)));  \n  \n};\n")))}p.isMDXComponent=!0}}]);