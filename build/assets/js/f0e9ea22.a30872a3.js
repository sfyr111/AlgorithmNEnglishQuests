"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[5501],{5680:(e,r,t)=>{t.d(r,{xA:()=>u,yg:()=>f});var n=t(6540);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function o(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?o(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function i(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=n.createContext({}),c=function(e){var r=n.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):s(s({},r),e)),t},u=function(e){var r=c(e.components);return n.createElement(l.Provider,{value:r},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},y=n.forwardRef((function(e,r){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(t),y=a,f=p["".concat(l,".").concat(y)]||p[y]||d[y]||o;return t?n.createElement(f,s(s({ref:r},u),{},{components:t})):n.createElement(f,s({ref:r},u))}));function f(e,r){var t=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=y;var i={};for(var l in r)hasOwnProperty.call(r,l)&&(i[l]=r[l]);i.originalType=e,i[p]="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=t[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}y.displayName="MDXCreateElement"},6777:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var n=t(8168),a=(t(6540),t(5680));const o={},s="94. Binary Tree Inorder Traversal",i={unversionedId:"trees/Binary Tree Inorder Traversal",id:"trees/Binary Tree Inorder Traversal",title:"94. Binary Tree Inorder Traversal",description:"94. Binary Tree Inorder Traversal",source:"@site/docs/trees/94. Binary Tree Inorder Traversal.md",sourceDirName:"trees",slug:"/trees/Binary Tree Inorder Traversal",permalink:"/docs/trees/Binary Tree Inorder Traversal",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/trees/94. Binary Tree Inorder Traversal.md",tags:[],version:"current",sidebarPosition:94,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"424.\xa0Longest Repeating\xa0Character\xa0Replacement",permalink:"/docs/sliding window/Longest Repeating\xa0Character\xa0Replacement"},next:{title:"98. Validate Binary Search Tree",permalink:"/docs/trees/Validate Binary Search Tree"}},l={},c=[{value:"<strong>Inorder Traversal (Left, Node, Right)</strong>",id:"inorder-traversal-left-node-right",level:3}],u={toc:c},p="wrapper";function d(e){let{components:r,...t}=e;return(0,a.yg)(p,(0,n.A)({},u,t,{components:r,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"94-binary-tree-inorder-traversal"},"94. Binary Tree Inorder Traversal"),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/binary-tree-inorder-traversal/"},"94. Binary Tree Inorder Traversal")),(0,a.yg)("h3",{id:"inorder-traversal-left-node-right"},(0,a.yg)("strong",{parentName:"h3"},"Inorder Traversal (Left, Node, Right)")),(0,a.yg)("p",null,"Inorder traversal of a binary tree visits the nodes in a left-middle-right order."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Recursive Approach"),": In this method, we first call the function recursively to traverse the left subtree. Then, we process the current node. Finally, we call the function recursively again to traverse the right subtree."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Iterative Approach"),": Here, we use a stack to simulate the recursive process. We start at the root and go as far left as possible, pushing each node onto the stack. When we can't go left anymore, we pop a node from the stack, process it, and then try to go right. This process repeats until we've processed all nodes.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-typescript"},"function inorderTraversal(root: TreeNode | null): number[] {  \n  // inorder: left - middle - right  \n  const result: number[] = [];  \n  \n  function traveerse(node: TreeNode) {  \n    if (node === null) {  \n      return;  \n    }  \n    traveerse(node.left);  \n    result.push(node.val);  \n    traveerse(node.right);  \n  }  \n  \n  traveerse(root);  \n  return result;  \n};\n\nfunction inorderTraversal(root: TreeNode | null): number[] {  \n  // inorder: left - middle - right  \n  const stack: TreeNode[] = [];  \n  const result: number[] = [];  \n  let current = root;  \n  \n  while (current || stack.length > 0) {  \n    while (current) {  \n      stack.push(current);  \n      current = current.left;  \n    }    current = stack.pop();  \n    result.push(current.val);  \n    current = current.right;  \n  }  \n  \n  return result;  \n};\n")))}d.isMDXComponent=!0}}]);