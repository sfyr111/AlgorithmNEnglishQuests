"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[6597],{5680:(e,n,t)=>{t.d(n,{xA:()=>d,yg:()=>h});var o=t(6540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=o.createContext({}),s=function(e){var n=o.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},d=function(e){var n=s(e.components);return o.createElement(p.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(t),m=r,h=c["".concat(p,".").concat(m)]||c[m]||u[m]||i;return t?o.createElement(h,a(a({ref:n},d),{},{components:t})):o.createElement(h,a({ref:n},d))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=m;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[c]="string"==typeof e?e:r,a[1]=l;for(var s=2;s<i;s++)a[s]=t[s];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6368:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var o=t(8168),r=(t(6540),t(5680));const i={},a="138.\xa0Copy List with Random Pointer",l={unversionedId:"linklist/Copy List with Random Pointer",id:"linklist/Copy List with Random Pointer",title:"138.\xa0Copy List with Random Pointer",description:"138.\xa0Copy List with Random Pointer",source:"@site/docs/linklist/138.\xa0Copy List with Random Pointer.md",sourceDirName:"linklist",slug:"/linklist/Copy List with Random Pointer",permalink:"/AlgorithmNEnglishQuests/docs/linklist/Copy List with Random Pointer",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/linklist/138.\xa0Copy List with Random Pointer.md",tags:[],version:"current",sidebarPosition:138,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"[92.\xa0Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)",permalink:"/AlgorithmNEnglishQuests/docs/linklist/Reverse Linked List II"},next:{title:"Linked List Cycle",permalink:"/AlgorithmNEnglishQuests/docs/linklist/Linked List Cycle"}},p={},s=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],d={toc:s},c="wrapper";function u(e){let{components:n,...t}=e;return(0,r.yg)(c,(0,o.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"138copy-list-with-random-pointer"},"138.\xa0Copy List with Random Pointer"),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/copy-list-with-random-pointer/"},"138.\xa0Copy List with Random Pointer")),(0,r.yg)("h2",{id:"problem"},"Problem"),(0,r.yg)("p",null,"A linked list of length\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"n"),"\xa0is given such that each node contains an\xa0additional\xa0random pointer, which could point to any node in the list, or\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"null"),"."),(0,r.yg)("p",null,"Construct\xa0a\xa0",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Object_copying#Deep_copy"},(0,r.yg)("strong",{parentName:"a"},"deep copy")),"\xa0of the list. The deep copy should consist of\xa0exactly\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"n"),"\xa0",(0,r.yg)("strong",{parentName:"p"},"brand new"),"\xa0nodes, where each new node has its value set to the value of its\xa0corresponding\xa0original\xa0node. Both the\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"next"),"\xa0and\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"random"),"\xa0pointer of the new nodes should point to new nodes in the copied list such that the pointers in the\xa0original\xa0list and copied list\xa0represent\xa0the same list state.\xa0",(0,r.yg)("strong",{parentName:"p"},"None of the pointers in the new list should point to nodes in the\xa0original\xa0list"),"."),(0,r.yg)("p",null,"For example, if there are two nodes\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"X"),"\xa0and\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"Y"),"\xa0in the\xa0original\xa0list, where\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"X.random --\x3e Y"),", then for the\xa0corresponding\xa0two nodes\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"x"),"\xa0and\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"y"),"\xa0in the copied list,\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"x.random --\x3e y"),"."),(0,r.yg)("p",null,"Return\xa0",(0,r.yg)("em",{parentName:"p"},"the head of the copied linked list"),"."),(0,r.yg)("p",null,"The linked list is\xa0represented\xa0in the input/output as a list of\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"n"),"\xa0nodes. Each node is\xa0represented\xa0as a\xa0pair\xa0of\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"[val, random_index]"),"\xa0where:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"val"),": an integer\xa0representing\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"Node.val")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"random_index"),": the\xa0index\xa0of the node (range from\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"0"),"\xa0to\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"n-1"),") that the\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"random"),"\xa0pointer points to, or\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"null"),"\xa0if it does not point to any node.")),(0,r.yg)("p",null,"Your code will\xa0",(0,r.yg)("strong",{parentName:"p"},"only"),"\xa0be given the\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"head"),"\xa0of the\xa0original\xa0linked list."),(0,r.yg)("h2",{id:"solution"},"Solution"),(0,r.yg)("p",null,"To solve the problem of copying a linked list with an extra random pointer, we use two primary steps. In the first step, we create a map that stores old nodes and their corresponding new copy nodes. To do this, we traverse the list once, create a copy node for every node, and put it in the map.\nIn the second step, we traverse the list again and set pointers for the new copy nodes. We use the map to find the copy nodes and then set the 'next' and 'random' pointers to the corresponding old node for each new copy node. If 'next' or 'random' is null, the new node also points to null.\nFinally, we return a new list head that is a copy of the original list head from the map. This way, we create a complete copy of the list with all pointers set correctly."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-typescript"},"function copyRandomList(head: Node | null): Node | null {  \n  let map = new Map<Node, Node>();  \n  \n  let current = head;  \n  while (current) {  \n    map.set(current, new Node(current.val));  \n    current = current.next;  \n  }  \n  \n  current = head;  \n  while (current) {  \n    const newNode = map.get(current);  \n    newNode.next = current.next ? map.get(current.next) : null;  \n    newNode.random = current.random ? map.get(current.random) : null;  \n    current = current.next;  \n  }  \n  \n  return map.get(head);  \n};\n")))}u.isMDXComponent=!0}}]);