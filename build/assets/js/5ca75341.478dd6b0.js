"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[8350],{5680:(e,t,r)=>{r.d(t,{xA:()=>p,yg:()=>f});var n=r(6540);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=u(r),d=o,f=h["".concat(l,".").concat(d)]||h[d]||c[d]||a;return r?n.createElement(f,i(i({ref:t},p),{},{components:r})):n.createElement(f,i({ref:t},p))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:o,i[1]=s;for(var u=2;u<a;u++)i[u]=r[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},6049:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var n=r(8168),o=(r(6540),r(5680));const a={},i="543.\xa0Diameter\xa0of Binary Tree",s={unversionedId:"trees/Diameter\xa0of Binary Tree",id:"trees/Diameter\xa0of Binary Tree",title:"543.\xa0Diameter\xa0of Binary Tree",description:"543.\xa0Diameter\xa0of Binary Tree",source:"@site/docs/trees/543.\xa0Diameter\xa0of Binary Tree.md",sourceDirName:"trees",slug:"/trees/Diameter\xa0of Binary Tree",permalink:"/AlgorithmNEnglishQuests/docs/trees/Diameter\xa0of Binary Tree",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/trees/543.\xa0Diameter\xa0of Binary Tree.md",tags:[],version:"current",sidebarPosition:543,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"297. Serialize and Deserialize Binary Tree",permalink:"/AlgorithmNEnglishQuests/docs/trees/Serialize and Deserialize Binary Tree"},next:{title:"572.\xa0Subtree of Another Tree",permalink:"/AlgorithmNEnglishQuests/docs/trees/Subtree of Another Tree"}},l={},u=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],p={toc:u},h="wrapper";function c(e){let{components:t,...r}=e;return(0,o.yg)(h,(0,n.A)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"543diameterof-binary-tree"},"543.\xa0Diameter\xa0of Binary Tree"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/diameter-of-binary-tree/"},"543.\xa0Diameter\xa0of Binary Tree")),(0,o.yg)("h2",{id:"problem"},"Problem"),(0,o.yg)("p",null,"Given the\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"root"),"\xa0of a binary tree, return\xa0",(0,o.yg)("em",{parentName:"p"},"the length of the\xa0",(0,o.yg)("strong",{parentName:"em"},"diameter"),"\xa0of the tree"),"."),(0,o.yg)("p",null,"The\xa0",(0,o.yg)("strong",{parentName:"p"},"diameter"),"\xa0of a binary tree is the\xa0",(0,o.yg)("strong",{parentName:"p"},"length"),"\xa0of the longest path between any two nodes in a tree. This path may or may not pass through the\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"root"),"."),(0,o.yg)("p",null,"The\xa0",(0,o.yg)("strong",{parentName:"p"},"length"),"\xa0of a path between two nodes is\xa0represented\xa0by the number of edges between them."),(0,o.yg)("h2",{id:"solution"},"Solution"),(0,o.yg)("p",null,"To find the diameter. We use a helper function, depth, to calculate the depth of each node recursively."),(0,o.yg)("p",null,"The depth function checks if the node is null. If it is, it means we are at the end of a path, so we return 0. If not, we find the depth of the left and right subtrees."),(0,o.yg)("p",null,"At each node, we update the diameter to be the maximum of the current diameter or the sum of the depths of the left and right subtrees. This is because the longest path through this node is the sum of the longest paths in its left and right subtrees."),(0,o.yg)("p",null,"Finally, we add 1 to the maximum depth of the left or right subtree to include the current node in the depth count.  It represents the maximum depth of the subtree rooted at the current node."),(0,o.yg)("p",null,"We start this process at the root, and the final diameter value is the answer. This approach makes sure we look at all possible paths and find the longest one."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-typescript"},"function diameterOfBinaryTree(root: TreeNode | null): number {  \n  let depth = 0;  \n  \n  function dfs(node: TreeNode) {  \n    if (node === null) {  \n      return 0;  \n    }  \n    const left = dfs(node.left);  \n    const right = dfs(node.right);  \n  \n    depth = Math.max(depth, left + right);  \n  \n    return 1 + Math.max(left, right);  \n  }  \n  \n  dfs(root);  \n  \n  return depth;  \n};\n")))}c.isMDXComponent=!0}}]);