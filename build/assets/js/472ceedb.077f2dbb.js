"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[6193],{5680:(e,r,t)=>{t.d(r,{xA:()=>u,yg:()=>h});var n=t(6540);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function a(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?a(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=n.createContext({}),d=function(e){var r=n.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},u=function(e){var r=d(e.components);return n.createElement(l.Provider,{value:r},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},m=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(t),m=o,h=c["".concat(l,".").concat(m)]||c[m]||p[m]||a;return t?n.createElement(h,i(i({ref:r},u),{},{components:t})):n.createElement(h,i({ref:r},u))}));function h(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=m;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s[c]="string"==typeof e?e:o,i[1]=s;for(var d=2;d<a;d++)i[d]=t[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6115:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var n=t(8168),o=(t(6540),t(5680));const a={},i="105.\xa0Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal",s={unversionedId:"trees/Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal",id:"trees/Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal",title:"105.\xa0Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal",description:"105.\xa0Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal",source:"@site/docs/trees/105.\xa0Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal.md",sourceDirName:"trees",slug:"/trees/Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal",permalink:"/AlgorithmNEnglishQuests/docs/trees/Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/trees/105.\xa0Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal.md",tags:[],version:"current",sidebarPosition:105,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"104.\xa0Maximum Depth of Binary Tree",permalink:"/AlgorithmNEnglishQuests/docs/trees/Maximum Depth of Binary Tree"},next:{title:"108. Convert Sorted Array to Binary Search Tree",permalink:"/AlgorithmNEnglishQuests/docs/trees/Convert Sorted Array to Binary Search Tree"}},l={},d=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],u={toc:d},c="wrapper";function p(e){let{components:r,...t}=e;return(0,o.yg)(c,(0,n.A)({},u,t,{components:r,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"105constructbinary-tree-frompreorderand-inorder-traversal"},"105.\xa0Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"},"105.\xa0Construct\xa0Binary Tree from\xa0Preorder\xa0and Inorder Traversal")),(0,o.yg)("h2",{id:"problem"},"Problem"),(0,o.yg)("p",null,"Given two integer arrays\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"preorder"),"\xa0and\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"inorder"),"\xa0where\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"preorder"),"\xa0is the\xa0preorder\xa0traversal of a binary tree and\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"inorder"),"\xa0is the inorder traversal of the same tree,\xa0construct\xa0and return\xa0",(0,o.yg)("em",{parentName:"p"},"the binary tree"),"."),(0,o.yg)("h2",{id:"solution"},"Solution"),(0,o.yg)("p",null,"To rebuild a binary tree from preorder and inorder traversals, we use the fact that the first element in the preorder list is the root of the tree. Then, we find this root in the inorder list, which tells us which nodes are in the left subtree and which are in the right subtree."),(0,o.yg)("p",null,"Here's how we solve it:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"We take the first element from the preorder list to create the root node."),(0,o.yg)("li",{parentName:"ol"},"We locate this root in the inorder list to separate the nodes into left and right subtrees."),(0,o.yg)("li",{parentName:"ol"},"The nodes after the root in the preorder list are part of the left subtree,followed by the right subtree's nodes."),(0,o.yg)("li",{parentName:"ol"},"With this information, we recursively build the left subtree using the parts of the preorder and inorder lists that correspond to the left subtree. Then we do the same for the right subtree."),(0,o.yg)("li",{parentName:"ol"},"We repeat this process for all nodes, thus reconstructing the entire binary tree.")),(0,o.yg)("p",null,"The key to solving this recursive problem is to understand how to use the information in both traversal lists to determine the structure of the tree."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-typescript"},"function buildTree(preorder: number[], inorder: number[]): TreeNode | null {  \n  if (preorder.length === 0 || inorder.length === 0) {  \n    return null;  \n  }  \n  \n  let rootValue = preorder[0];  \n  let root = new TreeNode(rootValue);  \n  let mid = inorder.indexOf(rootValue);  \n  \n  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));  \n  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));  \n  \n  return root;  \n};\n")))}p.isMDXComponent=!0}}]);