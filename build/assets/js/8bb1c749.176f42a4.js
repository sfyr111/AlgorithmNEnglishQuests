"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[9593],{4115:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>g});var r=t(8168),i=(t(6540),t(5680));const o={},s="5. Longest Palindromic Substring",a={unversionedId:"dynamic/Longest Palindromic Substring & 647. Palindromic Substrings",id:"dynamic/Longest Palindromic Substring & 647. Palindromic Substrings",title:"5. Longest Palindromic Substring",description:"5. Longest Palindromic Substring",source:"@site/docs/dynamic/5. Longest Palindromic Substring & 647. Palindromic Substrings.md",sourceDirName:"dynamic",slug:"/dynamic/Longest Palindromic Substring & 647. Palindromic Substrings",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/Longest Palindromic Substring & 647. Palindromic Substrings",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/dynamic/5. Longest Palindromic Substring & 647. Palindromic Substrings.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"981.\xa0Time Based Key-Value Store",permalink:"/AlgorithmNEnglishQuests/docs/binary search/Time Based Key-Value Store"},next:{title:"62. Unique Paths",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/Unique Paths"}},l={},g=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2},{value:"Be better",id:"be-better",level:2},{value:"Problem",id:"problem-1",level:2},{value:"Solution",id:"solution-1",level:2}],p={toc:g},u="wrapper";function c(e){let{components:n,...t}=e;return(0,i.yg)(u,(0,r.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"5-longest-palindromic-substring"},"5. Longest Palindromic Substring"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/longest-palindromic-substring/"},"5. Longest Palindromic Substring")),(0,i.yg)("h2",{id:"problem"},"Problem"),(0,i.yg)("p",null,"Given a string\xa0",(0,i.yg)("inlineCode",{parentName:"p"},"s"),", return\xa0",(0,i.yg)("em",{parentName:"p"},"the longest"),"\xa0",(0,i.yg)("em",{parentName:"p"},"palindromic")),(0,i.yg)("h2",{id:"solution"},"Solution"),(0,i.yg)("p",null,"To solve this problem, we can image an existing palindrome string in ",(0,i.yg)("inlineCode",{parentName:"p"},"s,")," assuming that there are two points at the middle point of the palindrome string extending outward to the edge. Then, we return the string at the left-to-right pointer. If ",(0,i.yg)("inlineCode",{parentName:"p"},"s")," are many palindrome strings, we need to keep track of the maximum length substring, and at the end, we return the greatest length substring. So we iterate through the ",(0,i.yg)("inlineCode",{parentName:"p"},"s")," at each position usage while looping to process. We need to process twice at the same position. Because palindrome string length is possibly odd or even, if odd, left and right pointers begin at the ",(0,i.yg)("inlineCode",{parentName:"p"},"i"),"; if the length is even, left at the ",(0,i.yg)("inlineCode",{parentName:"p"},"i"),", and right at the ",(0,i.yg)("inlineCode",{parentName:"p"},"i + 1"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-typescript"},"function longestPalindrome(s: string): string {  \n  let res = '';  \n  let resLen = 0;  \n  \n  for (let i = 0; i < s.length; i++) {  \n    // odd  \n    let l = i, r = i;  \n  \n    while (l >= 0 && r < s.length && s[l] === s[r]) {  \n      if ((r - l + 1) > resLen) {  \n        res = s.slice(l, r + 1);  \n        resLen = res.length;  \n      }  \n      l--;  \n      r++;  \n    }  \n    // even  \n    l = i, r = i + 1;  \n    while (l >= 0 && r < s.length && s[l] === s[r]) {  \n      if ((r - l + 1) > resLen) {  \n        res = s.slice(l, r + 1);  \n        resLen = res.length;  \n      }  \n      l--;  \n      r++;  \n    }  }  \n  return res;  \n};\n\n")),(0,i.yg)("h2",{id:"be-better"},"Be better"),(0,i.yg)("p",null,"We find the longest palindrome in a string by checking around each character, for both odd and even lengths. For odd palindromes, we see if expanding from one middle point gives us a palindrome. For even palindromes, we do the same but with two middle points next to each other. We keep track of the longest palindrome we find and return it."),(0,i.yg)("h1",{id:"647-palindromic-substrings"},"647. Palindromic Substrings"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/palindromic-substrings/"},"647. Palindromic Substrings")),(0,i.yg)("h2",{id:"problem-1"},"Problem"),(0,i.yg)("p",null,"Given a string\xa0",(0,i.yg)("inlineCode",{parentName:"p"},"s"),", return\xa0",(0,i.yg)("em",{parentName:"p"},"the number of\xa0",(0,i.yg)("strong",{parentName:"em"},"palindromic substrings"),"\xa0in it"),"."),(0,i.yg)("p",null,"A string is a\xa0",(0,i.yg)("strong",{parentName:"p"},"palindrome"),"\xa0when it reads the same backward as\xa0forward."),(0,i.yg)("p",null,"A\xa0",(0,i.yg)("strong",{parentName:"p"},"substring"),"\xa0is a\xa0contiguous\xa0sequence\xa0of characters\xa0within\xa0the string."),(0,i.yg)("h2",{id:"solution-1"},"Solution"),(0,i.yg)("p",null,"Similarly to the above question, we use the same approach to solve instead of keeping track of the maximum palindromic substring length to count palindromic substrings."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-typescript"},"function countSubstrings(s: string): number {\n    let res = 0;\n    \n    for (let i = 0; i < s.length; i++) {\n        let l = i;\n        let r = i;\n\n        while (l >= 0 && r < s.length && s[l] === s[r]) {\n            res += 1;\n            l -= 1;\n            r += 1;\n        }\n\n        l = i;\n        r = i + 1;\n\n        while (l >= 0 && r < s.length && s[l] === s[r]) {\n            res += 1;\n            l -= 1;\n            r += 1;\n        }\n    }\n    \n    return res;\n};\n")))}c.isMDXComponent=!0},5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>d});var r=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function a(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=r.createContext({}),g=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=g(e.components);return r.createElement(l.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=a(e,["components","mdxType","originalType","parentName"]),u=g(t),m=i,d=u["".concat(l,".").concat(m)]||u[m]||c[m]||o;return t?r.createElement(d,s(s({ref:n},p),{},{components:t})):r.createElement(d,s({ref:n},p))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,s=new Array(o);s[0]=m;var a={};for(var l in n)hasOwnProperty.call(n,l)&&(a[l]=n[l]);a.originalType=e,a[u]="string"==typeof e?e:i,s[1]=a;for(var g=2;g<o;g++)s[g]=t[g];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);