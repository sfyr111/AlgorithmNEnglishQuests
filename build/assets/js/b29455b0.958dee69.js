"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[2916],{5224:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(8168),r=(n(6540),n(5680));const o={},l=void 0,s={unversionedId:"linklist/Intersection of Two Linked Lists",id:"linklist/Intersection of Two Linked Lists",title:"Intersection of Two Linked Lists",description:"Problem",source:"@site/docs/linklist/160.\xa0Intersection of Two Linked Lists.md",sourceDirName:"linklist",slug:"/linklist/Intersection of Two Linked Lists",permalink:"/docs/linklist/Intersection of Two Linked Lists",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/linklist/160.\xa0Intersection of Two Linked Lists.md",tags:[],version:"current",sidebarPosition:160,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"143. Reorder List",permalink:"/docs/linklist/Reorder List"},next:{title:"[203.\xa0Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/)",permalink:"/docs/linklist/Remove Linked List Elements"}},a={},c=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,r.yg)(p,(0,i.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h2",{id:"problem"},"Problem"),(0,r.yg)("p",null,"Given the heads of two singly linked-lists\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"headA"),"\xa0and\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"headB"),", return\xa0",(0,r.yg)("em",{parentName:"p"},"the node at which the two lists intersect"),". If the two linked lists have no intersection at all, return\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"null"),"."),(0,r.yg)("h2",{id:"solution"},"Solution"),(0,r.yg)("p",null,"Since the linked lists might have different lengths, directly comparing their nodes can be challenging. To address this, we can use two pointers to traverse each list. Once a pointer reaches the end of its respective list, reset it to point to the head of the other linked list. This way, each pointer will traverse the total length of both lists. We start by creating two pointers, ",(0,r.yg)("inlineCode",{parentName:"p"},"list1")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"list2"),", pointing to the head nodes of the two linked lists. Use a while loop to continue as long as the two pointers are not equal. When one list reaches its end, redirect its pointer to the head of the other list. Finally, the intersection is found when the two pointers point to the same node, which we then return. If the lists do not intersect, both pointers will eventually point to ",(0,r.yg)("inlineCode",{parentName:"p"},"null"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {  \n  let list1 = headA;  \n  let list2 = headB;  \n  \n  while (list1 !== list2) {  \n    list1 = list1 ? list1.next : headB;  \n    list2 = list2 ? list2.next : headA;  \n  }  \n  \n  return list1;  \n};\n")))}u.isMDXComponent=!0},5680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>f});var i=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var a=i.createContext({}),c=function(e){var t=i.useContext(a),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(a.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,a=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,f=p["".concat(a,".").concat(h)]||p[h]||u[h]||o;return n?i.createElement(f,l(l({ref:t},d),{},{components:n})):i.createElement(f,l({ref:t},d))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=h;var s={};for(var a in t)hasOwnProperty.call(t,a)&&(s[a]=t[a]);s.originalType=e,s[p]="string"==typeof e?e:r,l[1]=s;for(var c=2;c<o;c++)l[c]=n[c];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);