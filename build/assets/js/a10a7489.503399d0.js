"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[876],{5680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>v});var a=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,v=u["".concat(l,".").concat(m)]||u[m]||h[m]||o;return n?a.createElement(v,i(i({ref:t},c),{},{components:n})):a.createElement(v,i({ref:t},c))}));function v(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7665:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(8168),r=(n(6540),n(5680));const o={},i="150.\xa0Evaluate\xa0Reverse\xa0Polish Notation",s={unversionedId:"Stack/Evaluate\xa0Reverse\xa0Polish Notation",id:"Stack/Evaluate\xa0Reverse\xa0Polish Notation",title:"150.\xa0Evaluate\xa0Reverse\xa0Polish Notation",description:"150.\xa0Evaluate\xa0Reverse\xa0Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)",source:"@site/docs/Stack/150.\xa0Evaluate\xa0Reverse\xa0Polish Notation.md",sourceDirName:"Stack",slug:"/Stack/Evaluate\xa0Reverse\xa0Polish Notation",permalink:"/docs/Stack/Evaluate\xa0Reverse\xa0Polish Notation",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Stack/150.\xa0Evaluate\xa0Reverse\xa0Polish Notation.md",tags:[],version:"current",sidebarPosition:150,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"22.\xa0Generate Parentheses",permalink:"/docs/Stack/Generate Parentheses"},next:{title:"155.\xa0Min Stack",permalink:"/docs/Stack/Min Stack"}},l={},p=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],c={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,r.yg)(u,(0,a.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"150evaluatereversepolish-notation"},"150.\xa0Evaluate\xa0Reverse\xa0Polish Notation"),(0,r.yg)("p",null,"150.\xa0Evaluate\xa0Reverse\xa0Polish Notation](",(0,r.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/evaluate-reverse-polish-notation/"},"https://leetcode.com/problems/evaluate-reverse-polish-notation/"),")"),(0,r.yg)("h2",{id:"problem"},"Problem"),(0,r.yg)("p",null,"You are given an array of strings\xa0",(0,r.yg)("inlineCode",{parentName:"p"},"tokens"),"\xa0that\xa0represents\xa0an arithmetic\xa0expression\xa0in a\xa0",(0,r.yg)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Reverse_Polish_notation"},"Reverse\xa0Polish Notation"),"."),(0,r.yg)("p",null,"Evaluate\xa0the\xa0expression. Return\xa0",(0,r.yg)("em",{parentName:"p"},"an integer that\xa0represents\xa0the value of the\xa0expression"),"."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Note"),"\xa0that:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The valid operators are\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"'+'"),",\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"'-'"),",\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"'*'"),", and\xa0",(0,r.yg)("inlineCode",{parentName:"li"},"'/'"),"."),(0,r.yg)("li",{parentName:"ul"},"Each operand may be an integer or another\xa0expression."),(0,r.yg)("li",{parentName:"ul"},"The division between two integers always\xa0",(0,r.yg)("strong",{parentName:"li"},"truncates toward zero"),"."),(0,r.yg)("li",{parentName:"ul"},"There will not be any division by zero."),(0,r.yg)("li",{parentName:"ul"},"The input\xa0represents\xa0a valid arithmetic\xa0expression\xa0in a\xa0reverse\xa0polish notation."),(0,r.yg)("li",{parentName:"ul"},"The answer and all the intermediate calculations can be\xa0represented\xa0in a\xa0",(0,r.yg)("strong",{parentName:"li"},"32-bit"),"\xa0integer.")),(0,r.yg)("h2",{id:"solution"},"Solution"),(0,r.yg)("p",null,"To solve this problem, we use a stack to process the tokens. As we iterate through each token, we perform the following actions: If token is a number, we push it onto the stack. If it's an operator (+, -, *, /), we pop the top two values from the stack, apply the operation, and push the result back onto the stack. Be careful with the order when subtract or divide. After processing all the tokens, the stack will contain one final value, which is the result of the RPN expression, and we return this value."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-typescript"},"function evalRPN(tokens: string[]): number {  \n  let stack: number[] = [];  \n  for (let c of tokens) {  \n    if (c === '+') {  \n      let a = stack.pop();  \n      let b = stack.pop();  \n      stack.push(b + a);  \n    } else if (c === '-') {  \n      let a = stack.pop();  \n      let b = stack.pop();  \n      stack.push(b - a);  \n    } else if (c === '*') {  \n      let a = stack.pop();  \n      let b = stack.pop();  \n      stack.push(b * a);  \n    } else if (c === '/') {  \n      let a = stack.pop();  \n      let b = stack.pop();  \n      stack.push(b / a | 0);  \n    } else {  \n      stack.push(Number(c));  \n    }  }  \n  return stack[0];  \n};\n")))}h.isMDXComponent=!0}}]);