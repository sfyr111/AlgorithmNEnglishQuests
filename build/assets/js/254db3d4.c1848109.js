"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[2053],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>g});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),p=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),m=a,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return t?r.createElement(g,i(i({ref:n},c),{},{components:t})):r.createElement(g,i({ref:n},c))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8638:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=t(8168),a=(t(6540),t(5680));const o={},i="91. Decode Ways",s={unversionedId:"dynamic/Decode Ways",id:"dynamic/Decode Ways",title:"91. Decode Ways",description:"Problem",source:"@site/docs/dynamic/91. Decode Ways.md",sourceDirName:"dynamic",slug:"/dynamic/Decode Ways",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/Decode Ways",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/dynamic/91. Decode Ways.md",tags:[],version:"current",sidebarPosition:91,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"70. Climbing Stairs",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/Climbing Stairs"},next:{title:"139. Word Break",permalink:"/AlgorithmNEnglishQuests/docs/dynamic/Word Break"}},l={},p=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],c={toc:p},u="wrapper";function d(e){let{components:n,...t}=e;return(0,a.yg)(u,(0,r.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"91-decode-ways"},"91. Decode Ways"),(0,a.yg)("h1",{id:"91-decode-ways-1"},(0,a.yg)("a",{parentName:"h1",href:"https://leetcode.com/problems/decode-ways/"},"91. Decode Ways")),(0,a.yg)("h2",{id:"problem"},"Problem"),(0,a.yg)("p",null,"A message containing letters from\xa0",(0,a.yg)("inlineCode",{parentName:"p"},"A-Z"),"\xa0can be\xa0",(0,a.yg)("strong",{parentName:"p"},"encoded"),"\xa0into numbers using the following mapping:"),(0,a.yg)("p",null,"'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\""),(0,a.yg)("p",null,"To\xa0",(0,a.yg)("strong",{parentName:"p"},"decode"),"\xa0an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping\xa0above\xa0(there may be multiple ways). For example,\xa0",(0,a.yg)("inlineCode",{parentName:"p"},'"11106"'),"\xa0can be mapped into:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},'"AAJF"'),"\xa0with the grouping\xa0",(0,a.yg)("inlineCode",{parentName:"li"},"(1 1 10 6)")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},'"KJF"'),"\xa0with the grouping\xa0",(0,a.yg)("inlineCode",{parentName:"li"},"(11 10 6)"))),(0,a.yg)("p",null,"Note that the grouping\xa0",(0,a.yg)("inlineCode",{parentName:"p"},"(1 11 06)"),"\xa0is\xa0invalid\xa0because\xa0",(0,a.yg)("inlineCode",{parentName:"p"},'"06"'),"\xa0cannot be mapped into\xa0",(0,a.yg)("inlineCode",{parentName:"p"},"'F'"),"\xa0since\xa0",(0,a.yg)("inlineCode",{parentName:"p"},'"6"'),"\xa0is different from\xa0",(0,a.yg)("inlineCode",{parentName:"p"},'"06"'),"."),(0,a.yg)("p",null,"Given a string\xa0",(0,a.yg)("inlineCode",{parentName:"p"},"s"),"\xa0containing only digits, return\xa0",(0,a.yg)("em",{parentName:"p"},"the\xa0",(0,a.yg)("strong",{parentName:"em"},"number"),"\xa0of ways to\xa0",(0,a.yg)("strong",{parentName:"em"},"decode"),"\xa0it"),"."),(0,a.yg)("p",null,"The test cases are generated so that the answer fits in a\xa0",(0,a.yg)("strong",{parentName:"p"},"32-bit"),"\xa0integer."),(0,a.yg)("h2",{id:"solution"},"Solution"),(0,a.yg)("p",null,"We use dynamic programming to solve this. It breaks big problems into small parts."),(0,a.yg)("p",null,"I think this way because we can see each part of the string as a small piece. Each piece can be a letter. '1' is 'A', '2' is 'B', and so on. But, '12' can also be 'L'. So, we look at one number and two numbers together."),(0,a.yg)("p",null,"We start from the end of the string to the start. We check each number to see how it can be letters. The last number has one way. For others, we see if one number or two numbers can be a letter. We add these ways up."),(0,a.yg)("p",null,"We must be careful for '0'. It can't be a letter alone. And two numbers together must be 26 or less."),(0,a.yg)("p",null,"We use a 'dp' hashtable to track how many ways each part can be letters. 'dp' at the end is 1 for an empty string."),(0,a.yg)("p",null,"Then, we fill 'dp' from back to start and return dp","[0]","."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-typescript"},'function numDecodings(s: string): number {\n    const dp: { [key: number]: number } = { [s.length]: 1 };\n\n    function helper(index: number): number {\n        if (dp[index]) {\n            return dp[index];\n        }\n        if (s[index] === "0") {\n            return 0;\n        }\n\n        let result: number = helper(index + 1);\n        if (\n            index < s.length - 1 &&\n            (s[index] === "1" || (s[index] === "2" && s[index + 1] < "7"))\n        ) {\n            result += helper(index + 2);\n        }\n        dp[index] = result;\n        return result;\n    }\n\n    return helper(0);\n};\n')))}d.isMDXComponent=!0}}]);