"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[2923],{1091:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var n=t(8168),o=(t(6540),t(5680));const a={},s="145. Binary Tree Postorder Traversal",l={unversionedId:"trees/Binary Tree Postorder Traversal",id:"trees/Binary Tree Postorder Traversal",title:"145. Binary Tree Postorder Traversal",description:"145. Binary Tree Postorder Traversal",source:"@site/docs/trees/145. Binary Tree Postorder Traversal.md",sourceDirName:"trees",slug:"/trees/Binary Tree Postorder Traversal",permalink:"/AlgorithmNEnglishQuests/docs/trees/Binary Tree Postorder Traversal",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/trees/145. Binary Tree Postorder Traversal.md",tags:[],version:"current",sidebarPosition:145,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"144. Binary Tree Preorder Traversal",permalink:"/AlgorithmNEnglishQuests/docs/trees/Binary Tree Preorder Traversal"},next:{title:"199.\xa0Binary Tree Right Side View",permalink:"/AlgorithmNEnglishQuests/docs/trees/Binary Tree Right Side View"}},i={},u=[{value:"<strong>Postorder Traversal (Left, Right, Node)</strong>",id:"postorder-traversal-left-right-node",level:3}],c={toc:u},d="wrapper";function p(e){let{components:r,...t}=e;return(0,o.yg)(d,(0,n.A)({},c,t,{components:r,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"145-binary-tree-postorder-traversal"},"145. Binary Tree Postorder Traversal"),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/binary-tree-postorder-traversal/"},"145. Binary Tree Postorder Traversal")),(0,o.yg)("h3",{id:"postorder-traversal-left-right-node"},(0,o.yg)("strong",{parentName:"h3"},"Postorder Traversal (Left, Right, Node)")),(0,o.yg)("p",null,"Postorder traversal visits the nodes in a left-right-middle order."),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Recursive Approach"),": This involves recursively calling the function for the left subtree, then for the right subtree, and finally processing the current node."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Iterative Approach"),": This is more complex due to the need to process a node after its subtrees. We use a stack and a variable to keep track of the last visited node. We traverse left as far as possible, then look at the right subtree. If the right subtree is either null or already visited, we can process the current node. We use the last visited node to determine whether the right subtree has been processed.")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-typescript"},"function postorderTraversal(root: TreeNode | null): number[] {  \n  // postorder left - right - middle  \n  const result: number[] = [];  \n  \n  function traversal(node: TreeNode) {  \n    if (node === null) {  \n      return;  \n    }  \n    traversal(node.left);  \n    traversal(node.right);  \n    result.push(node.val);  \n  }  \n  \n  traversal(root);  \n  return result;  \n};\n\nfunction postorderTraversal(root: TreeNode | null): number[] {  \n  // postorder left - right - middle  \n  const result: number[] = [];  \n  const stack: TreeNode[] = [];  \n  let current = root;  \n  let lastVisiter: TreeNode | null = null;  \n  \n  while (current || stack.length > 0) {  \n    while (current) {  \n      stack.push(current);  \n      current = current.left;  \n    }    current = stack[stack.length - 1];  \n    if (current.right === null || lastVisiter === current.right) {  \n      stack.pop();  \n      result.push(current.val);  \n      lastVisiter = current;  \n      current = null;  \n    } else {  \n      current = current.right;  \n    }  }  \n  \n  return result;  \n};\n")))}p.isMDXComponent=!0},5680:(e,r,t)=>{t.d(r,{xA:()=>c,yg:()=>g});var n=t(6540);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function a(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?a(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function l(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=n.createContext({}),u=function(e){var r=n.useContext(i),t=r;return e&&(t="function"==typeof e?e(r):s(s({},r),e)),t},c=function(e){var r=u(e.components);return n.createElement(i.Provider,{value:r},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},h=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(t),h=o,g=d["".concat(i,".").concat(h)]||d[h]||p[h]||a;return t?n.createElement(g,s(s({ref:r},c),{},{components:t})):n.createElement(g,s({ref:r},c))}));function g(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var a=t.length,s=new Array(a);s[0]=h;var l={};for(var i in r)hasOwnProperty.call(r,i)&&(l[i]=r[i]);l.originalType=e,l[d]="string"==typeof e?e:o,s[1]=l;for(var u=2;u<a;u++)s[u]=t[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"}}]);