"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[1287],{1337:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var n=t(8168),a=(t(6540),t(5680));const o={},s="144. Binary Tree Preorder Traversal",l={unversionedId:"trees/Binary Tree Preorder Traversal",id:"trees/Binary Tree Preorder Traversal",title:"144. Binary Tree Preorder Traversal",description:"144. Binary Tree Preorder Traversal",source:"@site/docs/trees/144. Binary Tree Preorder Traversal.md",sourceDirName:"trees",slug:"/trees/Binary Tree Preorder Traversal",permalink:"/AlgorithmNEnglishQuests/docs/trees/Binary Tree Preorder Traversal",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/trees/144. Binary Tree Preorder Traversal.md",tags:[],version:"current",sidebarPosition:144,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"124. Binary Tree Maximum Path Sum",permalink:"/AlgorithmNEnglishQuests/docs/trees/Binary Tree Maximum Path Sum"},next:{title:"145. Binary Tree Postorder Traversal",permalink:"/AlgorithmNEnglishQuests/docs/trees/Binary Tree Postorder Traversal"}},i={},u=[{value:"<strong>Preorder Traversal (Node, Left, Right)</strong>",id:"preorder-traversal-node-left-right",level:3}],c={toc:u},p="wrapper";function d(e){let{components:r,...t}=e;return(0,a.yg)(p,(0,n.A)({},c,t,{components:r,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"144-binary-tree-preorder-traversal"},"144. Binary Tree Preorder Traversal"),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/binary-tree-preorder-traversal/"},"144. Binary Tree Preorder Traversal")),(0,a.yg)("h3",{id:"preorder-traversal-node-left-right"},(0,a.yg)("strong",{parentName:"h3"},"Preorder Traversal (Node, Left, Right)")),(0,a.yg)("p",null,"Preorder traversal visits the nodes in a middle-left-right order."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Recursive Approach"),": We first process the current node, then recursively call the function for the left subtree, and finally, for the right subtree."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Iterative Approach"),": Similar to the inorder traversal but with a slight variation in the order. We use a stack and start by processing the node first before going left. We keep going left, processing nodes and pushing them onto the stack. When we can't go left anymore, we pop from the stack and go right.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-typescript"},"function preorderTraversal(root: TreeNode | null): number[] {  \n  // preorder middle - left - right  \n  const result: number[] = [];  \n  \n  function traversal(node: TreeNode) {  \n    if (node === null) {  \n      return;  \n    }  \n    result.push(node.val);  \n    traversal(node.left);  \n    traversal(node.right);  \n  }  \n  \n  traversal(root);  \n  return result;  \n};\n\nfunction preorderTraversal(root: TreeNode | null): number[] {  \n  // preorder middle - left - right  \n  const result: number[] = [];  \n  const stack: TreeNode[] = [];  \n  let current = root;  \n  \n  while (current || stack.length > 0) {  \n    while (current) {  \n      result.push(current.val);  \n      stack.push(current);  \n      current = current.left;  \n    }    current = stack.pop();  \n    current = current.right;  \n  }  \n  \n  return result;  \n};\n")))}d.isMDXComponent=!0},5680:(e,r,t)=>{t.d(r,{xA:()=>c,yg:()=>f});var n=t(6540);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function o(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?o(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function l(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var i=n.createContext({}),u=function(e){var r=n.useContext(i),t=r;return e&&(t="function"==typeof e?e(r):s(s({},r),e)),t},c=function(e){var r=u(e.components);return n.createElement(i.Provider,{value:r},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},g=n.forwardRef((function(e,r){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(t),g=a,f=p["".concat(i,".").concat(g)]||p[g]||d[g]||o;return t?n.createElement(f,s(s({ref:r},c),{},{components:t})):n.createElement(f,s({ref:r},c))}));function f(e,r){var t=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=g;var l={};for(var i in r)hasOwnProperty.call(r,i)&&(l[i]=r[i]);l.originalType=e,l[p]="string"==typeof e?e:a,s[1]=l;for(var u=2;u<o;u++)s[u]=t[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}g.displayName="MDXCreateElement"}}]);