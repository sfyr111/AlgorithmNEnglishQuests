"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[151],{5680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>h});var r=n(6540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),f=i,h=d["".concat(s,".").concat(f)]||d[f]||u[f]||a;return n?r.createElement(h,l(l({ref:t},c),{},{components:n})):r.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,l=new Array(a);l[0]=f;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<a;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},7268:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var r=n(8168),i=(n(6540),n(5680));const a={},l=void 0,o={unversionedId:"linklist/Palindrome Linked List",id:"linklist/Palindrome Linked List",title:"Palindrome Linked List",description:"234. Palindrome Linked List",source:"@site/docs/linklist/234. Palindrome Linked List.md",sourceDirName:"linklist",slug:"/linklist/Palindrome Linked List",permalink:"/docs/linklist/Palindrome Linked List",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/linklist/234. Palindrome Linked List.md",tags:[],version:"current",sidebarPosition:234,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"[206.\xa0Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)",permalink:"/docs/linklist/Reverse Linked List"},next:{title:"287.\xa0Find the Duplicate Number]",permalink:"/docs/linklist/Find the Duplicate Number"}},s={},p=[],c={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.yg)(d,(0,r.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("ol",{start:234},(0,i.yg)("li",{parentName:"ol"},"Palindrome Linked List\nProblem\nGiven the head of a singly linked list, return true if it is a palindrome or false otherwise.")),(0,i.yg)("p",null,"Solution\nFind the Middle of the List: We use two pointers, slow and fast. The slow pointer moves one node at a time, while the fast pointer moves two nodes. When the fast pointer reaches the end of the list, the slow pointer will be at the middle.\nReverse the Second Half of the List: Starting from the slow pointer, we reverse the second half of the list. We do this by reassigning the next pointer of each node in this half, effectively reversing the order of these nodes.\nCompare Both Sections: Finally, we compare the first half of the list with the reversed second half, node by node. Starting from the head of the list and the beginning of the reversed part, we check if the values of all corresponding nodes are equal. If they are, the list is a palindrome; otherwise, it's not.\nBy locating the middle of the list, reversing the second half, and then comparing the two halves, the function determines whether the linked list"),(0,i.yg)("p",null,"function isPalindrome(head: ListNode | null): boolean {",(0,i.yg)("br",{parentName:"p"}),"\n","// 1. place the slow pointer in the middle of list.",(0,i.yg)("br",{parentName:"p"}),"\n","let slow = head;",(0,i.yg)("br",{parentName:"p"}),"\n","let fast = head;"),(0,i.yg)("p",null,"while (fast !== null && fast.next !== null) {",(0,i.yg)("br",{parentName:"p"}),"\n","slow = slow.next;",(0,i.yg)("br",{parentName:"p"}),"\n","fast = fast.next.next;",(0,i.yg)("br",{parentName:"p"}),"\n","}"),(0,i.yg)("p",null,"// 2. reverse the end half of list.",(0,i.yg)("br",{parentName:"p"}),"\n","let prev = null;",(0,i.yg)("br",{parentName:"p"}),"\n","let cur = slow;"),(0,i.yg)("p",null,"while (cur !== null) {",(0,i.yg)("br",{parentName:"p"}),"\n","const next = cur.next;",(0,i.yg)("br",{parentName:"p"}),"\n","cur.next = prev;",(0,i.yg)("br",{parentName:"p"}),"\n","prev = cur;",(0,i.yg)("br",{parentName:"p"}),"\n","cur = next;",(0,i.yg)("br",{parentName:"p"}),"\n","}"),(0,i.yg)("p",null,"// 3. compare the start half and end half of list.",(0,i.yg)("br",{parentName:"p"}),"\n","let first = head;",(0,i.yg)("br",{parentName:"p"}),"\n","let second = prev;"),(0,i.yg)("p",null,"while (second !== null) {",(0,i.yg)("br",{parentName:"p"}),"\n","if (first.val !== second.val)",(0,i.yg)("br",{parentName:"p"}),"\n","return false;"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"first = first.next;  \nsecond = second.next;  \n")),(0,i.yg)("p",null,"}"),(0,i.yg)("p",null,"return true;",(0,i.yg)("br",{parentName:"p"}),"\n","}"))}u.isMDXComponent=!0}}]);