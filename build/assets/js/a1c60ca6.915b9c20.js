"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[3480],{1899:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>s});var n=t(8168),o=(t(6540),t(5680));const i={},l="226.\xa0Invert Binary Tree",a={unversionedId:"trees/Invert Binary Tree",id:"trees/Invert Binary Tree",title:"226.\xa0Invert Binary Tree",description:"Problem",source:"@site/docs/trees/226.\xa0Invert Binary Tree.md",sourceDirName:"trees",slug:"/trees/Invert Binary Tree",permalink:"/AlgorithmNEnglishQuests/docs/trees/Invert Binary Tree",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/trees/226.\xa0Invert Binary Tree.md",tags:[],version:"current",sidebarPosition:226,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"199.\xa0Binary Tree Right Side View",permalink:"/AlgorithmNEnglishQuests/docs/trees/Binary Tree Right Side View"},next:{title:"230. Kth Smallest Element in a BST",permalink:"/AlgorithmNEnglishQuests/docs/trees/Kth Smallest Element in a BST"}},u={},s=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],c={toc:s},p="wrapper";function h(e){let{components:r,...t}=e;return(0,o.yg)(p,(0,n.A)({},c,t,{components:r,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"226invert-binary-tree"},"226.\xa0Invert Binary Tree"),(0,o.yg)("h1",{id:"226invert-binary-tree-1"},(0,o.yg)("a",{parentName:"h1",href:"https://leetcode.com/problems/invert-binary-tree/"},"226.\xa0Invert Binary Tree")),(0,o.yg)("h2",{id:"problem"},"Problem"),(0,o.yg)("p",null,"Given the\xa0",(0,o.yg)("inlineCode",{parentName:"p"},"root"),"\xa0of a binary tree, invert the tree, and return\xa0",(0,o.yg)("em",{parentName:"p"},"its root"),"."),(0,o.yg)("h2",{id:"solution"},"Solution"),(0,o.yg)("p",null,"There are two methods in the code. Both methods do the same thing but in different ways."),(0,o.yg)("p",null,"The first method is recursive. We check if the node is not null. Then, swap left and right children. After that, we recursively call functions for left and right children."),(0,o.yg)("p",null,"The second method uses a queue. It's an iterative approach. We add root to the queue. Then, while the queue is not empty, we remove the first element. We swap its children. If children are not null, we add them to the queue."),(0,o.yg)("p",null,"Both methods return the root of the inverted tree."),(0,o.yg)("p",null,"So, in summary, this code inverts a binary tree. It can be done recursively or iteratively using a queue. Both methods swap left and right children of all nodes."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-typescript"},"function invertTree(root: TreeNode | null): TreeNode | null {\n  if (root === null) {\n    return null;\n  }\n\n  const temp = root.left;\n  root.left = root.right;\n  root.right = temp;\n\n\n  invertTree(root.left);\n  invertTree(root.right);\n\n  return root;\n};\n\nfunction invertTree(root: TreeNode | null): TreeNode | null {\n  let queue: Array<TreeNode> = [root];\n\n  while (queue.length !== 0) {\n    const current = queue.shift();\n\n    if (current !== null) {\n      [current.left, current.right] = [current.right, current.left];\n\n      current.left !== null && queue.push(current.left);\n      current.right !== null && queue.push(current.right);\n    }\n  }\n\n  return root;\n};\n")))}h.isMDXComponent=!0},5680:(e,r,t)=>{t.d(r,{xA:()=>c,yg:()=>y});var n=t(6540);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?i(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function a(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=n.createContext({}),s=function(e){var r=n.useContext(u),t=r;return e&&(t="function"==typeof e?e(r):l(l({},r),e)),t},c=function(e){var r=s(e.components);return n.createElement(u.Provider,{value:r},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},d=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,i=e.originalType,u=e.parentName,c=a(e,["components","mdxType","originalType","parentName"]),p=s(t),d=o,y=p["".concat(u,".").concat(d)]||p[d]||h[d]||i;return t?n.createElement(y,l(l({ref:r},c),{},{components:t})):n.createElement(y,l({ref:r},c))}));function y(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var i=t.length,l=new Array(i);l[0]=d;var a={};for(var u in r)hasOwnProperty.call(r,u)&&(a[u]=r[u]);a.originalType=e,a[p]="string"==typeof e?e:o,l[1]=a;for(var s=2;s<i;s++)l[s]=t[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);