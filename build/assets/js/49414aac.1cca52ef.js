"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[6110],{2681:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var o=n(8168),r=(n(6540),n(5680));const s={},i="143. Reorder List",l={unversionedId:"linklist/Reorder List",id:"linklist/Reorder List",title:"143. Reorder List",description:"143.\xa0Reorder List",source:"@site/docs/linklist/143. Reorder List.md",sourceDirName:"linklist",slug:"/linklist/Reorder List",permalink:"/docs/linklist/Reorder List",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/linklist/143. Reorder List.md",tags:[],version:"current",sidebarPosition:143,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"[142.\xa0Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)",permalink:"/docs/linklist/Linked List Cycle II"},next:{title:"Intersection of Two Linked Lists",permalink:"/docs/linklist/Intersection of Two Linked Lists"}},a={},d=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],c={toc:d},h="wrapper";function p(e){let{components:t,...n}=e;return(0,r.yg)(h,(0,o.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"143-reorder-list"},"143. Reorder List"),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/reorder-list/"},"143.\xa0Reorder List")),(0,r.yg)("h2",{id:"problem"},"Problem"),(0,r.yg)("p",null,"You are given the head of a singly linked-list. The list can be\xa0represented\xa0as:"),(0,r.yg)("p",null,"L0 \u2192 L1 \u2192 \u2026 \u2192 Ln - 1 \u2192 Ln"),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"Reorder the list to be on the following form:")),(0,r.yg)("p",null,"L0 \u2192 Ln \u2192 L1 \u2192 Ln - 1 \u2192 L2 \u2192 Ln - 2 \u2192 \u2026"),(0,r.yg)("p",null,"You may not modify the values in the list's nodes. Only nodes themselves may be changed."),(0,r.yg)("h2",{id:"solution"},"Solution"),(0,r.yg)("p",null,"To solve this problem, I plan to use the two-pointer method because it's efficient. First, I find the middle of the list. Slow pointer goes one step, fast pointer goes two steps. When fast pointer reaches the end, slow is in the middle."),(0,r.yg)("p",null,"Next, I reverse the second half of the list. This means changing the next of each node to the previous one."),(0,r.yg)("p",null,"Last step, I merge the two halves. I take one node from the first half and then one from the second half and combine them. This way, the list is reordered as required. It is a bit tricky but works well once you understand the steps."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-typescript"},"function reorderList(head: ListNode | null): void {\n  // Check if the list is empty or has only one node, in which case, do nothing.\n  if (!head || !head.next) return;\n\n  // Find the middle of the list using the fast and slow pointer technique.\n  // Slow moves one step at a time, while fast moves two steps.\n  let slow = head;\n  let fast = head.next; // fast starts at head.next to ensure that slow ends up at the middle or just before the middle in an even-length list.\n\n  // Keep moving until fast reaches the end of the list\n  while (fast && fast.next) {\n    slow = slow.next; // slow pointer moves one step\n    fast = fast.next.next; // fast pointer moves two steps\n  }\n\n  // Reverse the second half of the list.\n  // Start from the node right after the slow pointer.\n  let second = slow.next;\n  // Disconnect the first half and the second half of the list.\n  // This prevents any cycles from forming when we merge back later.\n  let prev = slow.next = null;\n\n  // Reverse the nodes of the second half in place.\n  while (second) {\n    const tmp = second.next;\n    second.next = prev;\n    prev = second;\n    second = tmp;\n  }\n\n  // Merge the two halves back together, taking nodes alternately from each half.\n  let first = head; // Start with the first node of the first half.\n  second = prev; // Start with the last node of the reversed second half.\n\n  // Weave the two halves together until we reach the end of the second half.\n  while (second) {\n    // Temporarily store the next nodes\n    const tmp1 = first.next;\n    const tmp2 = second.next;\n\n    // Reconnect nodes from the first and second halves\n    first.next = second; // First half node points to the next node of the second half.\n    second.next = tmp1; // Current second half node points to the next node of the first half.\n\n    // Move the pointers forward.\n    first = tmp1; // Move the pointer in the first half forward.\n    second = tmp2; // Move the pointer in the second half forward.\n  }\n};\n\n")))}p.isMDXComponent=!0},5680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>u});var o=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var a=o.createContext({}),d=function(e){var t=o.useContext(a),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return o.createElement(a.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,a=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=d(n),f=r,u=h["".concat(a,".").concat(f)]||h[f]||p[f]||s;return n?o.createElement(u,i(i({ref:t},c),{},{components:n})):o.createElement(u,i({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=f;var l={};for(var a in t)hasOwnProperty.call(t,a)&&(l[a]=t[a]);l.originalType=e,l[h]="string"==typeof e?e:r,i[1]=l;for(var d=2;d<s;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"}}]);