"use strict";(self.webpackChunkalgorithm_n_english_quests=self.webpackChunkalgorithm_n_english_quests||[]).push([[9763],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>m});var r=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(n),h=a,m=u["".concat(c,".").concat(h)]||u[h]||g[h]||o;return n?r.createElement(m,i(i({ref:t},p),{},{components:n})):r.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7601:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(8168),a=(n(6540),n(5680));const o={},i="424.\xa0Longest Repeating\xa0Character\xa0Replacement",l={unversionedId:"sliding window/Longest Repeating\xa0Character\xa0Replacement",id:"sliding window/Longest Repeating\xa0Character\xa0Replacement",title:"424.\xa0Longest Repeating\xa0Character\xa0Replacement",description:"424.\xa0Longest Repeating\xa0Character\xa0Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)",source:"@site/docs/sliding window/424.\xa0Longest Repeating\xa0Character\xa0Replacement.md",sourceDirName:"sliding window",slug:"/sliding window/Longest Repeating\xa0Character\xa0Replacement",permalink:"/docs/sliding window/Longest Repeating\xa0Character\xa0Replacement",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/sliding window/424.\xa0Longest Repeating\xa0Character\xa0Replacement.md",tags:[],version:"current",sidebarPosition:424,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"121.\xa0Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)",permalink:"/docs/sliding window/Best Time to Buy and Sell Stock"},next:{title:"94. Binary Tree Inorder Traversal",permalink:"/docs/trees/Binary Tree Inorder Traversal"}},c={},s=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}],p={toc:s},u="wrapper";function g(e){let{components:t,...n}=e;return(0,a.yg)(u,(0,r.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"424longest-repeatingcharacterreplacement"},"424.\xa0Longest Repeating\xa0Character\xa0Replacement"),(0,a.yg)("p",null,"424.\xa0Longest Repeating\xa0Character\xa0Replacement](",(0,a.yg)("a",{parentName:"p",href:"https://leetcode.com/problems/longest-repeating-character-replacement/"},"https://leetcode.com/problems/longest-repeating-character-replacement/"),")"),(0,a.yg)("h2",{id:"problem"},"Problem"),(0,a.yg)("p",null,"You are given a string\xa0",(0,a.yg)("inlineCode",{parentName:"p"},"s"),"\xa0and an integer\xa0",(0,a.yg)("inlineCode",{parentName:"p"},"k"),". You can choose any\xa0character\xa0of the string and change it to any other uppercase English\xa0character. You can\xa0perform\xa0this operation at most\xa0",(0,a.yg)("inlineCode",{parentName:"p"},"k"),"\xa0times."),(0,a.yg)("p",null,"Return\xa0",(0,a.yg)("em",{parentName:"p"},"the length of the longest substring containing the same letter you can get after\xa0performing\xa0the\xa0above\xa0operations"),"."),(0,a.yg)("h2",{id:"solution"},"Solution"),(0,a.yg)("p",null,"To solve this problem, we use a sliding window approach. Starting with both left and right pointers at the beginning of the string, we shift the right pointer to count each character. We track the maximum frequency of any character in the current window. If the window's length minus this maximum frequency exceeds ",(0,a.yg)("inlineCode",{parentName:"p"},"k"),", we shift the left pointer, reducing the count of the character at this position until the window satisfies the condition again. We continually update ",(0,a.yg)("inlineCode",{parentName:"p"},"res")," with the maximum length of the valid window. Finally, we return ",(0,a.yg)("inlineCode",{parentName:"p"},"res"),". This method ensures we find the answer."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"function characterReplacement(s: string, k: number): number {\n  let res = 0;\n  let count: Record<string, number> = {};\n  let left = 0;\n  let maxf = 0; // max frequency\n\n  for (let right = 0; right < s.length; right++) {\n    count[s[right]] = (count[s[right]] || 0) + 1;\n    maxf = Math.max(maxf, count[s[right]]);\n\n    // Calculate the window length inside the loop to ensure it's always up to date.\n    while ((right - left + 1) - maxf > k) {\n      count[s[left]] -= 1;\n      // If the character at the `left` was the max frequency character and its count has decreased,\n      // `maxf` may need to be recalculated. This is a potential inefficiency.\n      left++;\n    }\n\n    // Now, calculate `windowlen` after the while loop to get the current window size.\n    let windowlen = right - left + 1;\n    res = Math.max(res, windowlen);\n  }\n\n  return res;\n};\n\n")))}g.isMDXComponent=!0}}]);